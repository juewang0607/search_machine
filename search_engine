//
//  main.cpp
//  search_machine
//
//  Created by Jue wang on 7/9/20.
//  Copyright © 2020 Jue wang. All rights reserved.
//
#include <iostream>
#include <iomanip>
#include <fstream>
#include <unordered_map>
#include <vector>
using namespace std;

// unprdered_map is the hashmap implemented in C++
unordered_map<string, int> wordLibrary;
unordered_map<string, int> stopWords;
unordered_map<string, vector<int>> index0;
vector<string> vLoadData;
vector<string> vSplitWords;

// parameter: absolute path of dataset
// no output, save all words in "unordered_map wordLibrary"

void loadWordLibrary(string path) {
    //initailzie container
    // read the element in the text
    string line;
    ifstream myfile(path);
    if (myfile.is_open())
    {
        while (getline (myfile, line))
        {
            wordLibrary[line.substr(2,line.length())] = 1;
        }
        myfile.close();
    }
    else cout<<"unable to open file";
    return;
}

// parameter: absolute path of stopword
// no output, save all stopwords in "unordered_map stopWords"
void loadStopWords(string path) {
    //initailzie container
    // read the element in the text
    string line;
    ifstream myfile(path);
    if (myfile.is_open())
    {
        while (getline (myfile, line))
        {
            stopWords[line.substr(0,line.length()-1)] = 1;
        }
        myfile.close();
    }
    else cout<<"unable to open file";
    return;
}


// parameter: absolute path of music dataset
// output: convert each music as a string, save them with a vector
vector<string> loadData(string path) {
    //initailzie container
    // read the element in the text
    string line;
    ifstream myfile(path);
    if (myfile.is_open())
    {
        // if the file has lines
        while (getline (myfile, line))
        {
            int start = line.find("geci");
            int interval = line.find("composer")-start;
            string str = line.substr(start+7,interval-10);
            str.erase(std::remove(str.begin(),str.end(),','),str.end());
            str.erase(std::remove(str.begin(),str.end(),'"'),str.end());
            str.erase(std::remove(str.begin(),str.end(),'['),str.end());
            str.erase(std::remove(str.begin(),str.end(),']'),str.end());
            str.erase(std::remove(str.begin(),str.end(),' '),str.end());
            //cout<<str<<endl;
            vLoadData.push_back(str);
        }
        myfile.close();
    }
    else cout<<"unable to open file";
    return vLoadData;
}



// parameter: music content, which is a string
// output: split that into a vector of strings (forward index)
// e.g. 繁华中落入空门 -> [繁华，中，落入，空门]
vector<string> splitWords(string line) {
    string saveData = "";
    while (line.length() != 0)
    {
        for (int i = 30;i>0;i -= 3)
        {
            string temp = line.substr(0,i);
            if (wordLibrary.count(temp) != 0)
            {
                saveData = temp;
                vSplitWords.push_back(saveData);
                break;
            }
        }
        line = line.substr(saveData.length(),line.length()+saveData.length());
    }
    return vSplitWords;
}

// parameter: music content, which is a string
// output: delete words in the 中文停用词库
vector<string> deleteWords(vector<string> v){
    vector<string> vDeleteWords;
    for (auto& x: v){
        if (stopWords.count(x) == 0)
           {
               vDeleteWords.push_back(x);
           }
    }
    return vDeleteWords;
}


/*
// parameter: vector(different music) of vector(various words within the music)
// no output, save index in "unordered_map index", word as key, list of music index who contains that word as value
void buildInvertIndex(vector<vector<string>> music) {
    for (auto& x: music)
    {
        
    }
    
}
*/



int main (){
    loadWordLibrary
        ("/Users/juewang/Desktop/search_machine/search_machine/百度分词词库.txt");
    loadStopWords("/Users/juewang/Desktop/search_machine/search_machine/中文停用词库.txt");
    loadData("/Users/juewang/Desktop/search_machine/search_machine/music.json");
    for(auto& x: vLoadData)
        splitWords(x);
    deleteWords(vSplitWords);
    return 0;
}
